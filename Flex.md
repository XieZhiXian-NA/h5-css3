# flex弹性盒布局 

## 概念

+ 是css种的有一种布局，主要用来代替浮动完成页面的布局 解决浮动带来的高度塌陷等一系列问题
+ flex可以使元素有弹性 让元素可以跟随页面的大小改变而改变
  
## 弹性容器

+ 要使用弹性盒必须先将一个元素设置为弹性容器  使用display设置弹性容器
  > display:flex 设置块级弹性容器 独占一行
    display:inline-flex设置为行内弹性容器
+ 属性
  + flex-direction 指定容器中弹性元素的排列方式
    > row 默认值  弹性元素在容器中水平排列（从左向右）float-left 123
      >> 主轴 自左向右
      row-reverse 弹性元素在容器中反向水平排列 (从右向左) float-right 321
      >> 主轴 自右向左
      column 纵向排列 自上而下
      column-reverse 自下而上
  + 主轴 弹性元素的排列方向
  + 侧轴 与主轴垂直方向的称为侧轴
  + flex-wrap 设置弹性元素是否在弹性容器中自动换行
  
    ```css
    当容器宽度不足以容纳元素 + flex-shrink:0
    flex-wrap:none 不换行          1 2
              wrap 沿着辅轴自动换行 3          3
              wrap-reverse 沿着辅轴反方向换行  1 2
    ```

    flex-flow:direction wrap 简写属性
  + justify-content 分配主轴上的空白空间（主轴上的元素如何排列----元素与元素之间的间距）
    > flex-start 元素沿着主轴起边排列
      flex-end 元素沿着主轴终边排列
      center   元素水平居中
      space-around 空白均匀分布到每个元素的两侧
      space-between 空白均匀分布到元素与元素之间
      space-evenly 空白只分布到元素的单侧
  + align-items 元素在辅轴上如何对齐
    > stretch 默认值 讲=将元素的长度都设置为相同的值
      flex-start 元素不会拉伸 沿着辅轴齐边对齐
      flex-end 元素不会拉伸 沿着辅轴终边对齐
      center 垂直居中
  + align-content
    > 分配辅轴上的空白空间

## 弹性元素

+ 弹性容器的直接子元才是弹性元素（弹性项）
+ 一个元素可以是弹性容器 也可以是弹性元素
+ 属性
  + flex-grow 指定元素的伸展系数 
    > 当父元素有多余空间时，子元素如何伸展
      父元素的剩余空间，会按照比列进行分配
      0：默认值 不填充
      1 2 3 数值越大 伸展得越多
  + flex-shrink 元素的收缩系数 当父元素的空间不足以容纳所有的子元素时，如何对子元素进行收缩
    > 1：默认值 等比例收缩
      0 1 2 3 值越大 收缩得越多 0:不收缩
  + align-self 用来覆盖弹性元素上的align-items 单个设置
  + flex-basis 元素的基础长度
    > 如果主轴是横向的 则该值指定的就是width
      如果主轴是纵向的 则该值指定的就是height
      默认值就是auto 表示参考的是元素给定的宽度或高度的值
  + flex:简写属性 顺序 增长 缩减 基础
    > auto    1 1 auto
      initial 0 1 auto
      none    0 0 auto 该元素没有弹性
      或者自己指定值
  + order 弹性元素的排列顺序




## 移动端

+ 像素 
  前端开发 
  + 物理像素 分辨率 1920*1080 屏幕中小点的数量
  + css像素  编写网页时 所使用的像素
  + 浏览器在现实网页时，需要将css像素转化为物理像素再呈现 
    > 默认情况下 在pc端 一个css像素 = 一个物理像素
  + 视口 屏幕中用来显示网页的区域
    > 查看视口的大小，来观察css像素和物理像素的比值
      默认情况下 网页100% 不放大 不缩小 视口大小为1920px
      视口宽度   1920px css像素
                1920px 物理像素
                此时 css像素与物理像素的比为1:1
      放大两倍 
      视口宽度  960px css像素
               1920px 物理像素
               此时 css像素：物理像素 1:2
  + 像素越小屏幕越清晰 不同的手机 物理像素不一样 750px等
  + 手机的像素点远远小于计算机的像素点 导致css/物理 不是1:1 而是1:0.5 导致网页元素非常的小
  + 移动端网页视口大小设置为980px(css像素) pc端网页可以在移动端正常访问
    > 但是如果网页的宽度超过了980 移动端的浏览器会自动对网页缩放以完整显示网页 但是用户体验不好
      所以写移动端网页时，需要设置合理的像素比 一般就为1:2  在移动端能正常显示
      将像素比设置为最佳像素比的视口大小 我们称为完美视口

      ```css
         <!--通过设置meta 将网页的视口设置为完美视口 device-width是浏览器可以得到手机的完美视口  -->
         <meta name="viewpoint" content="width=device-width">
      ```

  + 由于不同的像素比不同所以同样的375个像素在不同的设备下意义不一样 显示效果不一样
    > 不能再用px像素单位 
      vw 1vw=百分之一视口大小  100vw = 1个完美视口的大小 也就是铺满屏幕
      vw单位总是相对于视口来进行计算 

      ```css
      html{
          <!-- 对于750px的设计图 5.3333vw = 40px  -->
          <!-- 浏览器字体最小为12px 若果设置的字体小于12px 则会自动设为12px 所以需要将其扩大30倍 -->
          font-size:5.3333vw  
      }
      <!-- 1rem 对应一个html font-size值 -->
      width:1rem; 也就是40px 单位需要换算
      ```


## 响应式布局

+ 根据不同的设备或者窗口大小呈现不同的效果 同一个页面 而移动端是另一个页面份布局
+ 使用响应式布局，可以使一个网页适用于所有设备 关键是媒体查询
+ 媒体查询，可以为不同的设备 或者设备不同状态来分别设置样式
+ @media 查询规则{}
  + 媒体类型
    > all 所有设备
      print 打印设备
      screen 带屏幕的设备 浏览器和手机就是一种设备 only screen 对低版本的浏览器的兼容
      speech 屏幕阅读器  
      可以使用,连接多个媒体类型，他们之间就是一个或的关系
  + 媒体特性
    > width 视口的宽度
      min-width:视口最小宽度
      max-width:视口最大宽度
      height 视口的高度

      ```css
        <!-- 当视口大小 >= 500px样式才生效 -->
        @media (min-width:500px){
            body{
                background-color:#bfa;
            }
        }
        @media (min-width:500px) and (max-width:700px):{}500-700在之间才生效
        @media (min-width:500px) , (max-widht:300px);{} 或关系
        @media not(对后面的属性整个取反) screen and (min-width:500px){}
      ```

  + 断点 样式切换的分界点
    > 也就是网页的样式会在这个点时发生变化
      一般比较常用的断点:
       >> 小于768 超小屏幕 max-width:768px 手机
          大于768 小屏幕 min-width:768px
          大于992 中型屏幕 min-width:992px ipad
          大于1200 大屏幕 min-width:1200px 电脑 高清屏幕
+ 响应式设计的网页
  + 移动端优先
  + 渐近增强